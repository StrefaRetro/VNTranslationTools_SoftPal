<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ output extension=".cs" encoding="utf-8" #>
<#
    // Read the C++ header file (single source of truth) with UTF-8 encoding
    string headerPath = Host.ResolvePath(@"..\..\VNTextProxy\SharedConstants.h");
    string headerContent = File.ReadAllText(headerPath, Encoding.UTF8);

    // Parse #define statements (^ ensures line starts with #, excluding commented lines)
    var stringDefines = Regex.Matches(headerContent, @"^#define\s+(\w+)\s+L?""([^""]+)""", RegexOptions.Multiline);
    var intDefines = Regex.Matches(headerContent, @"^#define\s+(\w+)\s+(\d+)\s*$", RegexOptions.Multiline);
    // Char defines: 'x' (narrow) and u'x' (wide/unicode)
    var narrowCharDefines = Regex.Matches(headerContent, @"^#define\s+(\w+)\s+'([^']+)'", RegexOptions.Multiline);
    var wideCharDefines = Regex.Matches(headerContent, @"^#define\s+(\w+)\s+u'([^']+)'", RegexOptions.Multiline);
#>
// Auto-generated from VNTextProxy/SharedConstants.h - DO NOT EDIT
// Regenerated automatically during build

namespace VNTextPatch.Shared.Util
{
    internal static class SharedConstants
    {
<#
    foreach (Match m in stringDefines)
    {
        string name = m.Groups[1].Value;
        string value = m.Groups[2].Value;
#>
        public const string <#= name #> = "<#= value #>";
<#
    }

    foreach (Match m in intDefines)
    {
        string name = m.Groups[1].Value;
        string value = m.Groups[2].Value;
        // Treat 0/1 values with names containing LOGGING, BOOL, ENABLE, or DEBUG as booleans
        bool isBooleanFlag = (value == "0" || value == "1") &&
            (name.Contains("LOGGING") || name.Contains("BOOL") || name.Contains("ENABLE") || name.Contains("DEBUG"));
        if (isBooleanFlag)
        {
#>
        public static readonly bool <#= name #> = <#= value == "1" ? "true" : "false" #>;
<#
        }
        else
        {
#>
        public const int <#= name #> = <#= value #>;
<#
        }
    }

    foreach (Match m in narrowCharDefines)
    {
        string name = m.Groups[1].Value;
        string value = m.Groups[2].Value;
#>
        public const char <#= name #> = '<#= value #>';
<#
    }

    foreach (Match m in wideCharDefines)
    {
        string name = m.Groups[1].Value;
        string value = m.Groups[2].Value;
#>
        public const char <#= name #> = '<#= value #>';
<#
    }
#>
    }
}
